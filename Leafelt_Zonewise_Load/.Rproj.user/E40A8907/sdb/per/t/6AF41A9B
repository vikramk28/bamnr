{
    "contents" : "library(leaflet)\nlibrary(ggplot2)\nlibrary(maps)\nuspop2000 <- read.csv(\"C:/Users/abc/Desktop/R practice/r_csv/test_data_japnesh.csv\")\nd2 = uspop2000 %>%\n  group_by(Center,  Lat,  Long) %>%\n  summarise(ZnA = sum(Zn0), ZnB=sum(Zn1), ZnC = sum(Zn2), ZnD= sum(Zn3), ZnE = sum(Zn4))\nuspop2000 = d2\n# From a future version of Shiny\nbindEvent <- function(eventExpr, callback, env=parent.frame(), quoted=FALSE) {\n  eventFunc <- exprToFunction(eventExpr, env, quoted)\n  \n  initialized <- FALSE\n  invisible(observe({\n    eventVal <- eventFunc()\n    if (!initialized)\n      initialized <<- TRUE\n    else\n      isolate(callback())\n  }))\n}\n\nshinyServer(function(input, output, session) {\n  \n  makeReactiveBinding('selectedCenter')\n  \n  # Define some reactives for accessing the data\n  \n  # Retrieve the name of the column that contains the selected year's\n  # population\n  znCol <- reactive({\n    paste('Zn', input$zone, sep='')\n  })\n  \n  popSeries <- function(center) {\n    c(\n      sum(center$ZnA),\n      sum(center$ZnB),\n      sum(center$ZnC),\n      sum(center$ZnD),\n      sum(center$ZnE)\n    )\n  }\n  \n  # The cities that are within the visible bounds of the map\n  centersInBounds <- reactive({\n    if (is.null(input$map_bounds))\n      return(uspop2000[FALSE,])\n    bounds <- input$map_bounds\n    latRng <- range(bounds$north, bounds$south)\n    lngRng <- range(bounds$east, bounds$west)\n    \n    subset(uspop2000,\n           Lat >= latRng[1] & Lat <= latRng[2] &\n             Long >= lngRng[1] & Long <= lngRng[2])\n  })\n  \n  # The top N cities (by population) that are within the visible bounds\n  # of the map\n  topCentersInBounds <- reactive({\n    centers <- centersInBounds()\n    centers <- head(centers[order(centers[[znCol()]], decreasing=TRUE),],\n                   as.character(input$maxCenters))\n  })\n  \n  # Create the map; this is not the \"real\" map, but rather a proxy\n  # object that lets us control the leaflet map on the page.\n  map <- createLeafletMap(session, 'map')\n  \n  observe({\n    if (is.null(input$map_click))\n      return()\n    selectedCenter <<- NULL\n  })\n  \n  radiusFactor <- 1000\n  observe({\n    map$clearShapes()\n    centers <- topCentersInBounds()\n    \n    if (nrow(centers) == 0)\n      return()\n    \n    map$addCircle(\n      centers$Lat,\n      centers$Long,\n      sqrt(centers[[znCol()]]) * radiusFactor / max(5, input$map_zoom)^2,\n      row.names(centers),\n      list(\n        weight=1.2,\n        fill=TRUE,\n        color='black'\n      )\n    )\n  })\n  \n  observe({\n    event <- input$map_shape_click\n    if (is.null(event))\n      return()\n    map$clearPopups()\n    \n    isolate({\n      centers <- topCentersInBounds()\n      center <- centers[row.names(centers) == event$id,]\n      selectedCenter <<- center\n      content <- as.character(tagList(\n        tags$strong(paste(center$Center, center$State)),\n        tags$br(),\n        sprintf(\"Estimated Load Density, %s:\", input$zone),\n        tags$br(),\n        prettyNum(center[[znCol()]], big.mark=',')\n      ))\n      map$showPopup(event$lat, event$lng, content, event$id)\n    })\n  })\n  \n  output$desc <- reactive({\n    if (is.null(input$map_bounds))\n      return(list())\n    list(\n      lat = mean(c(input$map_bounds$north, input$map_bounds$south)),\n      lng = mean(c(input$map_bounds$east, input$map_bounds$west)),\n      zoom = input$map_zoom,\n      shownCenters = nrow(topCentersInBounds()),\n      totalCenters = nrow(centersInBounds())\n    )\n  })\n  \n  output$data <- renderTable({\n    if (nrow(topCentersInBounds()) == 0)\n      return(NULL)\n    \n    data.frame(\n      Center = paste(topCentersInBounds()$Center, topCentersInBounds()$State),\n      Load = topCentersInBounds()[[znCol()]])\n  }, include.rownames = FALSE)\n  \n  output$centerTimeSeriesLabel <- renderText({\n    if (is.null(selectedCenter)) {\n      'Total Load Density of visible centers'\n    } else {\n      paste('Load Dennsity of ',\n            selectedCenter$Center,\n            ', ',\n            selectedCenter$State,\n            sep='')\n    }\n  })\n  \n  output$centerTimeSeries <- renderPlot({\n    centers <- NULL\n    if (!is.null(selectedCenter))\n      centers <- selectedCenter\n    else\n      centers <- topCentersInBounds()\n    \n    popData <- popSeries(centers) / 1000\n    df <- data.frame(zone = c(\"A\",\"B\", \"C\", \"D\", \"E\"), pop = popData)\n    p <- ggplot(df, aes(x = zone, y = pop)) + geom_point()\n    p <- p + ylim(c(0, max(popData)))\n  p <- p + ylab('Load Density (thousands)')\n  #p <- p + scale_x_continuous(breaks = seq(\"A\",\"B\",\"C\",\"D\",\"E\"))\n    print(p)\n  })\n})\n",
    "created" : 1428903432391.000,
    "dirty" : false,
    "encoding" : "ISO8859-1",
    "folds" : "",
    "hash" : "2947533648",
    "id" : "6AF41A9B",
    "lastKnownWriteTime" : 1428920764,
    "path" : "C:/Users/abc/Desktop/R practice/custom_leafelt/server.R",
    "project_path" : "server.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}